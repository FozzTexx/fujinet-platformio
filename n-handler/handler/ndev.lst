mads 2.1.0 build 8 (23 Dec 19)
Source: ndev.s
     1 					;; N: Device Handler
     2 					;; Compile with MADS
     3
     4 					;; Author: Thomas Cherryhomes
     5 					;;   <thom.cherryhomes@gmail.com>
     6
     7 					;; CURRENT IOCB IN ZERO PAGE
     8 					
     9 = 0020			ZIOCB   =     $20      ; ZP IOCB
    10 = 0020			ZICHID  =     ZIOCB    ; ID
    11 = 0021			ZICDNO  =     ZIOCB+1  ; UNIT #
    12 = 0022			ZICCOM  =     ZIOCB+2  ; COMMAND
    13 = 0023			ZICSTA  =     ZIOCB+3  ; STATUS
    14 = 0024			ZICBAL  =     ZIOCB+4  ; BUF ADR LOW
    15 = 0025			ZICBAH  =     ZIOCB+5  ; BUF ADR HIGH
    16 = 0026			ZICPTL  =     ZIOCB+6  ; PUT ADDR L
    17 = 0027			ZICPTH  =     ZIOCB+7  ; PUT ADDR H
    18 = 0028			ZICBLL  =     ZIOCB+8  ; BUF LEN LOW
    19 = 0029			ZICBLH  =     ZIOCB+9  ; BUF LEN HIGH
    20 = 002A			ZICAX1  =     ZIOCB+10 ; AUX 1
    21 = 002B			ZICAX2  =     ZIOCB+11 ; AUX 2
    22 = 002C			ZICAX3  =     ZIOCB+12 ; AUX 3
    23 = 002D			ZICAX4  =     ZIOCB+13 ; AUX 4
    24 = 002E			ZICAX5  =     ZIOCB+14 ; AUX 5
    25 = 002F			ZICAX6  =     ZIOCB+15 ; AUX 6
    26
    27 = 000C			DOSINI  =     $0C      ; DOSINI
    28
    29 				       ; INTERRUPT VECTORS
    30 				       ; AND OTHER PAGE 2 VARS
    31
    32 = 0202			VPRCED  =     $0202   ; PROCEED VCTR
    33 = 02C6			COLOR2  =     $02C6   ; MODEF BKG C
    34 = 02E7			MEMLO   =     $02E7   ; MEM LO
    35 = 02EA			DVSTAT  =     $02EA   ; 4 BYTE STATS
    36
    37 				       ; PAGE 3
    38 				       ; DEVICE CONTROL BLOCK (DCB)
    39
    40 = 0300			DCB     =     $0300   ; BASE
    41 = 0300			DDEVIC  =     DCB     ; DEVICE #
    42 = 0301			DUNIT   =     DCB+1   ; UNIT #
    43 = 0302			DCOMND  =     DCB+2   ; COMMAND
    44 = 0303			DSTATS  =     DCB+3   ; STATUS/DIR
    45 = 0304			DBUFL   =     DCB+4   ; BUF ADR L
    46 = 0305			DBUFH   =     DCB+5   ; BUF ADR H
    47 = 0306			DTIMLO  =     DCB+6   ; TIMEOUT (S)
    48 = 0307			DRSVD   =     DCB+7   ; NOT USED
    49 = 0308			DBYTL   =     DCB+8   ; BUF LEN L
    50 = 0309			DBYTH   =     DCB+9   ; BUF LEN H
    51 = 030A			DAUXL   =     DCB+10  ; AUX BYTE L
    52 = 030B			DAUXH   =     DCB+11  ; AUX BYTE H
    53
    54 = 031A			HATABS  =     $031A   ; HANDLER TBL
    55
    56 				       ; IOCB'S * 8
    57
    58 = 0340			IOCB    =     $0340   ; IOCB BASE
    59 = 0340			ICHID   =     IOCB    ; ID
    60 = 0341			ICDNO   =     IOCB+1  ; UNIT #
    61 = 0342			ICCOM   =     IOCB+2  ; COMMAND
    62 = 0343			ICSTA   =     IOCB+3  ; STATUS
    63 = 0344			ICBAL   =     IOCB+4  ; BUF ADR LOW
    64 = 0345			ICBAH   =     IOCB+5  ; BUF ADR HIGH
    65 = 0346			ICPTL   =     IOCB+6  ; PUT ADDR L
    66 = 0347			ICPTH   =     IOCB+7  ; PUT ADDR H
    67 = 0348			ICBLL   =     IOCB+8  ; BUF LEN LOW
    68 = 0349			ICBLH   =     IOCB+9  ; BUF LEN HIGH
    69 = 034A			ICAX1   =     IOCB+10 ; AUX 1
    70 = 034B			ICAX2   =     IOCB+11 ; AUX 2
    71 = 034C			ICAX3   =     IOCB+12 ; AUX 3
    72 = 034D			ICAX4   =     IOCB+13 ; AUX 4
    73 = 034E			ICAX5   =     IOCB+14 ; AUX 5
    74 = 034F			ICAX6   =     IOCB+15 ; AUX 6
    75
    76 				       ; HARDWARE REGISTERS
    77
    78 = D302			PACTL   =     $D302   ; PIA CTRL A
    79
    80 				       ; OS ROM VECTORS
    81
    82 = E456			CIOV    =     $E456   ; CIO ENTRY
    83 = E459			SIOV    =     $E459   ; SIO ENTRY
    84
    85 				       ; CONSTANTS
    86
    87 = 0009			PUTREC  =     $09     ; CIO PUTREC
    88 = 0071			DEVIDN  =     $71     ; SIO DEVID
    89 = 0040			DSREAD  =     $40     ; FUJI->ATARI
    90 = 0080			DSWRIT  =     $80     ; ATARI->FUJI
    91 = 0004			MAXDEV  =     4       ; # OF N: DEVS
    92 = 0088			EOF     =     $88     ; ERROR 136
    93 = 009B			EOL     =     $9B     ; EOL CHAR
    94
    95 				;;; Macros ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    96
    97 					.MACRO DCBC
    98 					.LOCAL
    99 					LDY	#$0C
   100 				?DCBL	LDA	%%1,Y
   101 					STA	DCB,Y
   102 					DEY
   103 					BPL	?DCBL
   104 					.ENDL
   105 					.ENDM
   106 						
   107 				;;; Initialization ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   108 					
   109 				START:	
   110 FFFF> 3100-341B> A5 0C		LDA	DOSINI
   111 3102 8D 1A 34			STA	DSAV
   112 3105 8D 25 31			STA	RESET+1
   113 3108 A5 0D			LDA	DOSINI+1
   114 310A 8D 1B 34			STA	DSAV+1
   115 310D 8D 26 31			STA	RESET+2
   116 3110 A9 24			LDA	#<RESET
   117 3112 85 0C			STA	DOSINI
   118 3114 A9 31			LDA	#>RESET
   119 3116 85 0D			STA	DOSINI+1
   120
   121 					;;  Alter MEMLO
   122 					
   123 3118 A9 00			LDA	#<PGEND		
   124 311A 8D E7 02			STA	MEMLO
   125 311D A9 36			LDA	#>PGEND
   126 311F 8D E8 02			STA	MEMLO+1
   127
   128 3122 50 11			BVC	IHTBS
   129 					
   130 3124			RESET:
   131 3124 20 FF FF			JSR	$FFFF		; Jump to extant DOSINI
   132 3127 20 35 31			JSR	IHTBS		; Insert into HATABS
   133
   134 					;;  Alter MEMLO
   135 					
   136 312A A9 00			LDA	#<PGEND		
   137 312C 8D E7 02			STA	MEMLO
   138 312F A9 36			LDA	#>PGEND
   139 3131 8D E8 02			STA	MEMLO+1
   140
   141 					;; Back to DOS
   142 					
   143 3134 60				RTS
   144
   145 					;; Insert entry into HATABS
   146 					
   147 3135			IHTBS:
   148 3135 A0 00			LDY	#$00
   149 3137 B9 1A 03		IH1	LDA	HATABS,Y
   150 313A F0 0B			BEQ	HFND
   151 313C C9 4E			CMP	#'N'
   152 313E F0 07			BEQ	HFND
   153 3140 C8				INY
   154 3141 C8				INY
   155 3142 C8				INY
   156 3143 C0 21			CPY	#11*3
   157 3145 90 F0			BCC	IH1
   158
   159 					;; Found a slot
   160
   161 3147			HFND:
   162 3147 A9 4E			LDA	#'N'
   163 3149 99 1A 03			STA	HATABS,Y
   164 314C A9 F0			LDA	#<CIOHND
   165 314E 99 1B 03			STA	HATABS+1,Y
   166 3151 A9 33			LDA	#>CIOHND
   167 3153 99 1C 03			STA	HATABS+2,Y
   168
   169 					;; And we're done with HATABS
   170
   171 					;; Query FUJINET
   172
   173 3156 20 27 33			JSR	STPOLL
   174
   175 					;; Output Ready/Error
   176
   177 3159			OBANR:
   178 3159 A2 00			LDX	#$00		; IOCB #0
   179 315B A9 09			LDA	#PUTREC
   180 315D 9D 42 03			STA	ICCOM,X
   181 3160 A9 28			LDA	#$28		; 40 CHARS Max
   182 3162 9D 48 03			STA	ICBLL,X
   183 3165 A9 00			LDA	#$00
   184 3167 9D 49 03			STA	ICBLH,X
   185 316A AD 03 03			LDA	DSTATS		; Check DSTATS
   186 316D 10 0C			BPL	OBRDY		; < 128 = Ready
   187
   188 					;; Status returned error.
   189 					
   190 316F			OBERR:
   191 316F A9 0B			LDA	#<BERROR
   192 3171 9D 44 03			STA	ICBAL,X
   193 3174 A9 34			LDA	#>BERROR
   194 3176 9D 45 03			STA	ICBAH,X
   195 3179 50 0A			BVC	OBCIO
   196
   197 					;; Status returned ready.
   198 					
   199 317B			OBRDY:	
   200 317B A9 FC			LDA	#<BREADY
   201 317D 9D 44 03			STA	ICBAL,X
   202 3180 A9 33			LDA	#>BREADY
   203 3182 9D 45 03			STA	ICBAH,X
   204
   205 3185			OBCIO:
   206 3185 20 56 E4			JSR	CIOV
   207
   208 					;; Vector in proceed interrupt
   209
   210 3188			SPRCED:
   211 3188 A9 E9			LDA	#<PRCVEC
   212 318A 8D 02 02			STA	VPRCED
   213 318D A9 33			LDA	#>PRCVEC
   214 318F 8D 03 02			STA	VPRCED+1
   215
   216 					;; And we are done, back to DOS.
   217 					
   218 3192 60				RTS
   219
   220 				;;; End Initialization Code ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   221
   222 				;;; CIO OPEN ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   223
   224 3193			OPEN:
   225 					;; Prepare DCB
   226 					
   227 3193 20 E5 33			JSR	GDIDX		; Get Device ID in X (0-3)
   228 3196 A5 21			LDA	ZICDNO		; IOCB UNIT # (1-4)
   229 3198 8D E6 31			STA	OPNDCB+1	; Store in DUNIT
   230 319B A5 24			LDA	ZICBAL		; Get filename buffer
   231 319D 8D E9 31			STA	OPNDCB+4	; stuff in DBUF
   232 31A0 A5 25			LDA	ZICBAH		; ...
   233 31A2 8D EA 31			STA	OPNDCB+5	; ...
   234 31A5 A5 2A			LDA	ZICAX1		; Get desired AUX1/AUX2
   235 31A7 8D EF 31			STA	OPNDCB+10	; Save them, and store in DAUX1/DAUX2
   236 31AA 9D 1D 34			STA	AX1SV,X		; ...
   237 31AD A5 2B			LDA	ZICAX2		; ...
   238 31AF 8D F0 31			STA	OPNDCB+11	; ...
   239 31B2 9D 21 34			STA	AX2SV,X		; ...
   240
   241 					;;  Copy DCB template to DCB
   242 					
   243 31B5				DCBC	OPNDCB
Macro: DCBC [Source: ndev.s]
     2 31B5 A0 0C			LDY	#$0C
     3 31B7 B9 E5 31		?DCBL	LDA	OPNDCB,Y
     4 31BA 99 00 03			STA	DCB,Y
     5 31BD 88				DEY
     6 31BE 10 F7			BPL	?DCBL
Source: ndev.s
   244
   245 					;;  Send to #FujiNet
   246 					
   247 31C0 20 59 E4			JSR	SIOV
   248 				                                    
   249 					;; Return DSTATS, unless 144, then get extended error
   250 					
   251 31C3			OPCERR:
   252 31C3 AC 03 03			LDY	DSTATS		; GET SIO STATUS
   253 31C6 C0 90			CPY	#$90		; ERR 144?
   254 31C8 D0 06			BNE	OPDONE		; NOPE. RETURN DSTATS
   255 				       
   256 					;; 144 - get extended error
   257
   258 31CA 20 27 33			JSR	STPOLL  	; POLL FOR STATUS
   259 31CD AC ED 02			LDY	DVSTAT+3
   260
   261 				       ; RESET BUFFER LENGTH + OFFSET
   262 				       
   263 31D0			OPDONE:
   264 31D0 A9 01			LDA	#$01
   265 31D2 8D 1C 34			STA	TRIP
   266 31D5 20 E5 33			JSR     GDIDX
   267 31D8 A9 00			LDA     #$00
   268 31DA 9D 35 34			STA     RLEN,X
   269 31DD 9D 3D 34			STA     TOFF,X
   270 31E0 9D 39 34			STA     ROFF,X
   271 31E3 98				TYA
   272 31E4 60				RTS             ; AY = ERROR
   273
   274 31E5			OPNDCB:
   275 31E5 71				.BYTE      DEVIDN  ; DDEVIC
   276 31E6 FF				.BYTE      $FF     ; DUNIT
   277 31E7 4F				.BYTE      'O'     ; DCOMND
   278 31E8 80				.BYTE      $80     ; DSTATS
   279 31E9 FF				.BYTE      $FF     ; DBUFL
   280 31EA FF				.BYTE      $FF     ; DBUFH
   281 31EB 0F				.BYTE      $0F     ; DTIMLO
   282 31EC 00				.BYTE      $00     ; DRESVD
   283 31ED 00				.BYTE      $00     ; DBYTL
   284 31EE 01				.BYTE      $01     ; DBYTH
   285 31EF FF				.BYTE      $FF     ; DAUX1
   286 31F0 FF				.BYTE      $FF     ; DAUX2
   287 					
   288 				;;; End CIO OPEN ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   289
   290 				;;; CIO CLOSE ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   291
   292 31F1			CLOSE:	
   293 31F1 20 DC 33			JSR     DIPRCD		; Disable Interrupts
   294 31F4 20 E5 33			JSR	GDIDX
   295 31F7 20 AF 32			JSR	PFLUSH		; Do a Put Flush if needed.
   296
   297 31FA A5 21			LDA     ZICDNO		; IOCB Unit #
   298 31FC 8D 13 32			STA     CLODCB+1	; to DCB...
   299 					
   300 31FF				DCBC	CLODCB		; Copy DCB into place
Macro: DCBC [Source: ndev.s]
     2 31FF A0 0C			LDY	#$0C
     3 3201 B9 12 32		?DCBL	LDA	CLODCB,Y
     4 3204 99 00 03			STA	DCB,Y
     5 3207 88				DEY
     6 3208 10 F7			BPL	?DCBL
Source: ndev.s
   301
   302 320A 20 59 E4			JSR	SIOV
   303
   304 320D AC 03 03			LDY	DSTATS		; Return SIO status
   305 3210 98				TYA
   306 3211 60				RTS			; Done.
   307
   308 3212 71			CLODCB .BYTE	DEVIDN		; DDEVIC
   309 3213 FF			       .BYTE	$FF		; DUNIT
   310 3214 43			       .BYTE	'C'		; DCOMND
   311 3215 00			       .BYTE	$00		; DSTATS
   312 3216 00			       .BYTE	$00		; DBUFL
   313 3217 00			       .BYTE	$00		; DBUFH
   314 3218 0F			       .BYTE	$0F		; DTIMLO
   315 3219 00			       .BYTE	$00		; DRESVD
   316 321A 00			       .BYTE	$00		; DBYTL
   317 321B 00			       .BYTE	$00		; DBYTH
   318 321C 00			       .BYTE	$00		; DAUX1
   319 321D 00			       .BYTE	$00		; DAUX2
   320 					
   321 				;;; End CIO CLOSE ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   322
   323 				;;; CIO GET ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   324
   325 321E			GET:
   326 321E 20 E5 33			JSR	GDIDX		; IOCB UNIT #-1 into X 
   327 3221 BD 35 34			LDA	RLEN,X		; Get # of RX chars waiting
   328 3224 D0 37			BNE     GETDISC		; LEN > 0?
   329
   330 					;; If RX buffer is empty, get # of chars waiting...
   331 					
   332 3226 20 27 33			JSR	STPOLL		; Status Poll
   333 3229 20 E5 33			JSR	GDIDX		; IOCB UNIT -1 into X (because Poll trashes X)
   334 322C AD EA 02			LDA	DVSTAT		; # of bytes waiting (0-127)
   335 322F 9D 35 34			STA	RLEN,X		; Store in RX Len
   336 3232 D0 05			BNE     GETDO		; We have something waiting...
   337
   338 					;; At this point, if RLEN is still zero, then return
   339 					;; with an EOF.
   340 					
   341 3234 A0 88			LDY     #EOF		; ERROR 136 - End of File
   342 3236 A9 88			LDA     #EOF
   343 3238 60				RTS
   344
   345 3239			GETDO:
   346 3239 A5 21			LDA	ZICDNO		; Get IOCB UNIT #
   347 323B 8D 83 32			STA	GETDCB+1	; Store into DUNIT
   348 323E AD EA 02			LDA	DVSTAT		; # of bytes waiting
   349 3241 8D 8A 32			STA	GETDCB+8	; Store into DBYT...
   350 3244 8D 8C 32			STA	GETDCB+10	; and DAUX1...
   351 				       
   352 3247				DCBC	GETDCB		; Prepare DCB
Macro: DCBC [Source: ndev.s]
     2 3247 A0 0C			LDY	#$0C
     3 3249 B9 82 32		?DCBL	LDA	GETDCB,Y
     4 324C 99 00 03			STA	DCB,Y
     5 324F 88				DEY
     6 3250 10 F7			BPL	?DCBL
Source: ndev.s
   353 					
   354 3252 20 59 E4			JSR	SIOV		; Call SIO to do the GET
   355
   356 					;; Clear the Receive buffer offset.
   357 					
   358 3255 20 E5 33			JSR	GDIDX		; IOCB UNIT #-1 into X
   359 3258 A9 00			LDA	#$00
   360 325A 9D 39 34			STA     ROFF,X
   361
   362 325D			GETDISC:
   363 325D AD EC 02			LDA     DVSTAT+2	; Did we disconnect?
   364 3260 D0 05			BNE     GETUPDP		; nope, update the buffer cursor.
   365
   366 					;; We disconnected, emit an EOF.
   367 					
   368 3262 A9 88			LDA	#EOF
   369 3264 A0 88			LDY	#EOF
   370 3266 60				RTS			; buh-bye.
   371
   372 3267			GETUPDP:
   373 3267 DE 35 34			DEC     RLEN,X		; Decrement RX length.
   374 326A BC 39 34			LDY     ROFF,X		; Get RX offset cursor.
   375
   376 					;; Return Next char from appropriate RX buffer.
   377 					
   378 326D B9 00 35			LDA	RBUF,y
   379 					
   380 					;; Increment RX offset
   381 					
   382 3270 FE 39 34		GX:	INC	ROFF,X		; Increment RX offset.
   383 3273 A8				TAY			; stuff returned val into Y temporarily.
   384
   385 					;; If requested RX buffer is empty, reset TRIP.
   386
   387 3274 BD 35 34			LDA	RLEN,X
   388 3277 D0 05			BNE	GETDONE
   389 3279 A9 00			LDA     #$00
   390 327B 8D 1C 34			STA     TRIP
   391
   392 					;; Return byte back to CIO.
   393 					
   394 327E			GETDONE:
   395 327E 98				TYA			; Move returned val back.
   396 327F A0 01			LDY	#$01		; SUCCESS
   397
   398 3281 60				RTS			; DONE...
   399
   400 3282 71			GETDCB .BYTE     DEVIDN  ; DDEVIC
   401 3283 FF			       .BYTE     $FF     ; DUNIT
   402 3284 52			       .BYTE     'R'     ; DCOMND
   403 3285 40			       .BYTE     $40     ; DSTATS
   404 3286 00			       .BYTE     $00     ; DBUFL
   405 3287 35			       .BYTE     >RBUF   ; DBUFH
   406 3288 0F			       .BYTE     $0F     ; DTIMLO
   407 3289 00			       .BYTE     $00     ; DRESVD
   408 328A FF			       .BYTE     $FF     ; DBYTL
   409 328B 00			       .BYTE     $00     ; DBYTH
   410 328C FF			       .BYTE     $FF     ; DAUX1
   411 328D 00			       .BYTE     $00     ; DAUX2
   412 					
   413 				;;; End CIO GET ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   414
   415 				;;; CIO PUT ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   416
   417 328E			PUT:
   418 					;; Add to TX buffer.
   419
   420 328E 20 E5 33			JSR	GDIDX
   421 3291 BC 3D 34			LDY	TOFF,X  ; GET TX cursor.
   422 3294 99 80 35			STA	TBUF,Y		; TX Buffer
   423 					
   424 3297 FE 3D 34		POFF:	INC	TOFF,X		; Increment TX cursor
   425 329A A0 01			LDY	#$01		; SUCCESSFUL
   426
   427 					;; Do a PUT FLUSH if EOL or buffer full.
   428
   429 329C C9 9B			CMP     #EOL    ; EOL?
   430 329E F0 0B			BEQ     FLUSH  ; FLUSH BUFFER
   431 32A0 20 E5 33			JSR     GDIDX   ; GET OFFSET
   432 32A3 BD 3D 34			LDA     TOFF,X
   433 32A6 C9 7F		        CMP     #$7F    ; LEN = $FF?
   434 32A8 F0 01		        BEQ     FLUSH  ; FLUSH BUFFER
   435 32AA 60			        RTS
   436
   437 				       ; FLUSH BUFFER, IF ASKED.
   438
   439 32AB 20 AF 32		FLUSH  JSR     PFLUSH  ; FLUSH BUFFER
   440 32AE 60			       RTS
   441
   442 32AF			PFLUSH:	
   443
   444 				       ; CHECK CONNECTION, AND EOF
   445 				       ; IF DISCONNECTED.
   446
   447 32AF 20 27 33		       JSR     STPOLL  ; GET STATUS
   448 32B2 AD EC 02		       LDA     DVSTAT+2
   449 32B5 D0 05		       BNE     PF1   
   450 32B7 A0 88		       LDY     #EOF
   451 32B9 A9 88		       LDA     #EOF
   452 32BB 60			       RTS
   453
   454 32BC 20 E5 33		PF1:	JSR     GDIDX   ; GET DEV X
   455 32BF BD 3D 34		       LDA     TOFF,X
   456 32C2 D0 03		       BNE     PF2
   457 32C4 4C EB 32		       JMP     PDONE
   458
   459 				       ; FILL OUT DCB FOR PUT FLUSH
   460
   461 32C7 A5 21		PF2:	LDA     ZICDNO
   462 32C9 8D EF 32		       STA     PUTDCB+1
   463 					
   464 				       ; FINISH DCB AND DO SIOV
   465
   466 32CC BD 3D 34		TBX:	LDA     TOFF,X
   467 32CF 8D F6 32			STA     PUTDCB+8
   468 32D2 8D F8 32			STA     PUTDCB+10
   469
   470 32D5				DCBC	PUTDCB
Macro: DCBC [Source: ndev.s]
     2 32D5 A0 0C			LDY	#$0C
     3 32D7 B9 EE 32		?DCBL	LDA	PUTDCB,Y
     4 32DA 99 00 03			STA	DCB,Y
     5 32DD 88				DEY
     6 32DE 10 F7			BPL	?DCBL
Source: ndev.s
   471 32E0 20 59 E4			JSR     SIOV
   472 				       
   473 				       ; CLEAR THE OFFSET CURSOR
   474 				       ; AND LENGTH
   475
   476 32E3 20 E5 33		       JSR     GDIDX
   477 32E6 A9 00		       LDA     #$00
   478 32E8 9D 3D 34		       STA     TOFF,X
   479
   480 32EB A0 01		PDONE:	LDY     #$01
   481 32ED 60			       RTS
   482
   483 32EE 71			PUTDCB .BYTE      DEVIDN  ; DDEVIC
   484 32EF FF			       .BYTE      $FF     ; DUNIT
   485 32F0 57			       .BYTE      'W'     ; DCOMND
   486 32F1 80			       .BYTE      $80     ; DSTATS
   487 32F2 80			       .BYTE      $80     ; DBUFL
   488 32F3 35			       .BYTE      >TBUF   ; DBUFH
   489 32F4 0F			       .BYTE      $0F     ; DTIMLO
   490 32F5 00			       .BYTE      $00     ; DRESVD
   491 32F6 FF			       .BYTE      $FF     ; DBYTL
   492 32F7 00			       .BYTE      $00     ; DBYTH
   493 32F8 FF			       .BYTE      $FF     ; DAUX1
   494 32F9 00			       .BYTE      $00     ; DAUX2
   495 					
   496 				;;; End CIO PUT ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   497 					
   498 				;;; CIO STATUS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   499
   500 32FA			STATUS:
   501 32FA 20 D3 33			JSR     ENPRCD  ; ENABLE PRCD
   502 32FD 20 E5 33		       JSR     GDIDX   ; GET DEVICE#
   503 3300 BD 35 34		       LDA     RLEN,X  ; GET RLEN
   504 3303 D0 05		       BNE     STSLEN  ; RLEN > 0?
   505 3305 AD 1C 34		       LDA     TRIP
   506 3308 D0 0E		       BNE     STTRI1  ; TRIP = 1?
   507
   508 				       ; NO TRIP, RETURN SAVED LEN
   509
   510 330A BD 35 34		STSLEN LDA     RLEN,X  ; GET RLEN
   511 330D 8D EA 02		       STA     DVSTAT  ; RET IN DVSTAT
   512 3310 A9 00		       LDA     #$00
   513 3312 8D EB 02		       STA     DVSTAT+1
   514 3315 4C 23 33		       JMP     STDONE  ; DONE.
   515
   516 				       ; DO POLL AND UPDATE RCV LEN
   517
   518 3318 20 27 33		STTRI1 JSR     STPOLL  ; POLL FOR ST
   519 331B 9D 35 34			STA	RLEN,X
   520 						
   521 				       ; UPDATE TRIP FLAG
   522
   523 331E D0 03		STTRIU BNE     STDONE
   524 3320 8D 1C 34		       STA     TRIP    ; RLEN = 0
   525
   526 				       ; RETURN CONNECTED? FLAG.
   527
   528 3323 AD EC 02		STDONE LDA     DVSTAT+2
   529 3326 60			       RTS
   530
   531 				       ; ASK FUJINET FOR STATUS
   532
   533 3327			STPOLL:	
   534 3327 A5 21		       LDA     ZICDNO  ; IOCB #
   535 3329 8D 55 33		       STA     STADCB+1
   536
   537 332C				DCBC	STADCB
Macro: DCBC [Source: ndev.s]
     2 332C A0 0C			LDY	#$0C
     3 332E B9 54 33		?DCBL	LDA	STADCB,Y
     4 3331 99 00 03			STA	DCB,Y
     5 3334 88				DEY
     6 3335 10 F7			BPL	?DCBL
Source: ndev.s
   538
   539 3337 20 59 E4		       JSR     SIOV    ; DO IT...
   540
   541 					;; > 127 bytes? make it 127 bytes.
   542
   543 333A AD EB 02			LDA	DVSTAT+1
   544 333D D0 07			BNE	STADJ
   545 333F AD EA 02			LDA	DVSTAT
   546 3342 30 02			BMI	STADJ
   547 3344 50 0A			BVC	STP2		; <= 127 bytes...
   548
   549 3346 A9 7F		STADJ	LDA	#$7F
   550 3348 8D EA 02			STA	DVSTAT
   551 334B A9 00			LDA	#$00
   552 334D 8D EB 02			STA	DVSTAT+1
   553 					
   554 				       ; A = CONNECTION STATUS
   555
   556 3350 AD EC 02		STP2   LDA     DVSTAT+2
   557 3353 60			       RTS
   558
   559 3354 71			STADCB .BYTE      DEVIDN  ; DDEVIC
   560 3355 FF			       .BYTE      $FF     ; DUNIT
   561 3356 53			       .BYTE      'S'     ; DCOMND
   562 3357 40			       .BYTE      $40     ; DSTATS
   563 3358 EA			       .BYTE      $EA     ; DBUFL
   564 3359 02			       .BYTE      $02     ; DBUFH
   565 335A 0F			       .BYTE      $0F     ; DTIMLO
   566 335B 00			       .BYTE      $00     ; DRESVD
   567 335C 04			       .BYTE      $04     ; DBYTL
   568 335D 00			       .BYTE      $00     ; DBYTH
   569 335E 00			       .BYTE      $00     ; DAUX1
   570 335F 00			       .BYTE      $00     ; DAUX2
   571 					
   572 				;;; End CIO STATUS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   573
   574 				;;; CIO SPECIAL ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   575
   576 3360			SPEC:
   577 				       ; HANDLE LOCAL COMMANDS.
   578
   579 3360 A5 22		       LDA     ZICCOM
   580 3362 C9 0F		       CMP     #$0F    ; 15 = FLUSH
   581 3364 D0 06		       BNE     S1      ; NO.
   582 3366 20 AF 32		       JSR     PFLUSH  ; DO FLUSH
   583 3369 A0 01		       LDY     #$01    ; SUCCESS
   584 336B 60			       RTS
   585
   586 				       ; HANDLE SIO COMMANDS.
   587 				       ; GET DSTATS FOR COMMAND
   588
   589 336C A5 21		S1:	LDA	ZICDNO
   590 336E 8D C8 33			STA	SPEDCB+1
   591 3371 A5 22			LDA	ZICCOM
   592 3373 8D D1 33			STA	SPEDCB+10
   593 					
   594 3376				DCBC	SPEDCB
Macro: DCBC [Source: ndev.s]
     2 3376 A0 0C			LDY	#$0C
     3 3378 B9 C7 33		?DCBL	LDA	SPEDCB,Y
     4 337B 99 00 03			STA	DCB,Y
     5 337E 88				DEY
     6 337F 10 F7			BPL	?DCBL
Source: ndev.s
   595 3381 20 59 E4		       JSR     SIOV    ; DO IT...
   596
   597 3384 AD 03 03		       LDA     DSTATS
   598 3387 10 02		       BPL     :DSOK
   599 3389			DSERR:
   600 3389 A8				TAY             ; RET THE ERR
   601 338A 60			       RTS
   602
   603 				       ; WE GOT A DSTATS INQUIRY
   604 				       ; IF $FF, THE COMMAND IS
   605 				       ; INVALID
   606
   607 338B			DSOK:
   608 338B AD 41 34			LDA     INQDS
   609 338E C9 FF		       CMP     #$FF    ; INVALID?
   610 3390 D0 04		       BNE     DSGO   ; DO THE CMD
   611 3392 A0 92		       LDY     #$92    ; UNIMP CMD
   612 3394 98			       TYA
   613 3395 60			       RTS
   614
   615 					;; Do the special, since we want to pass in all the IOCB
   616 					;; Parameters to the DCB, This is being done long-hand.
   617 					
   618 3396 A5 22		DSGO:	LDA	ZICCOM
   619 3398 8D 02 03			STA	DCOMND
   620 339B AD 41 34			LDA	INQDS
   621 339E 8D 03 03			STA	DSTATS
   622 33A1 A5 24			LDA	ZICBAL
   623 33A3 8D 04 03			STA	DBUFL
   624 33A6 A5 25			LDA	ZICBAH
   625 33A8 8D 05 03			STA	DBUFH
   626 33AB A9 00			LDA	#$00		; 256 bytes
   627 33AD 8D 08 03			STA	DBYTL
   628 33B0 A9 01			LDA	#$01
   629 33B2 8D 09 03			STA	DBYTH
   630 33B5 A5 2A			LDA	ZICAX1
   631 33B7 8D 0A 03			STA	DAUXL
   632 33BA A5 2B			LDA	ZICAX2
   633 33BC 8D 0B 03			STA	DAUXH
   634
   635 33BF 20 59 E4			JSR	SIOV
   636
   637 					;; Return DSTATS in Y and A
   638
   639 33C2 AD 03 03			LDA	DSTATS
   640 33C5 A8				TAY
   641
   642 33C6 60				RTS
   643
   644 33C7 71			SPEDCB .BYTE      DEVIDN  ; DDEVIC
   645 33C8 FF			       .BYTE      $FF     ; DUNIT
   646 33C9 FF			       .BYTE      $FF     ; DCOMND ; inq
   647 33CA 40			       .BYTE      $40     ; DSTATS
   648 33CB 41			       .BYTE      <INQDS  ; DBUFL
   649 33CC 34			       .BYTE      >INQDS  ; DBUFH
   650 33CD 0F			       .BYTE      $0F     ; DTIMLO
   651 33CE 00			       .BYTE      $00     ; DRESVD
   652 33CF 01			       .BYTE      $01     ; DBYTL
   653 33D0 00			       .BYTE      $00     ; DBYTH
   654 33D1 FF			       .BYTE      $FF     ; DAUX1
   655 33D2 FF			       .BYTE      $FF     ; DAUX2	
   656 					
   657 				;;; End CIO SPECIAL ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   658
   659 				;;; Utility Functions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   660
   661 				       ; ENABLE PROCEED INTERRUPT
   662
   663 33D3			ENPRCD:
   664 33D3 AD 02 D3			LDA     PACTL
   665 33D6 09 01		       ORA     #$01    ; ENABLE BIT 0
   666 33D8 8D 02 D3		       STA     PACTL
   667 33DB 60			       RTS
   668
   669 				       ; DISABLE PROCEED INTERRUPT
   670
   671 33DC			DIPRCD:
   672 33DC AD 02 D3			LDA     PACTL
   673 33DF 29 FE		       AND     #$FE    ; DISABLE BIT0
   674 33E1 8D 02 D3		       STA     PACTL
   675 33E4 60			       RTS
   676
   677 				       ; GET ZIOCB DEVNO - 1 INTO X
   678 				       
   679 33E5			GDIDX:	
   680 33E5 A6 21		       LDX     ZICDNO  ; IOCB UNIT #
   681 33E7 CA			       DEX             ; - 1
   682 33E8 60			       RTS
   683 					
   684 				;;; End Utility Functions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   685
   686 				;;; Proceed Vector ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   687
   688 33E9			PRCVEC 
   689 33E9 A9 01		       LDA     #$01
   690 33EB 8D 1C 34		       STA     TRIP
   691 33EE 68			       PLA
   692 33EF 40			       RTI
   693 					
   694 				;;; End Proceed Vector ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   695
   696 				;;; Variables
   697
   698 				       ; DEVHDL TABLE FOR N:
   699
   700 33F0 92 31		CIOHND .WORD      OPEN-1
   701 33F2 F0 31		       .WORD      CLOSE-1
   702 33F4 1D 32		       .WORD      GET-1
   703 33F6 8D 32		       .WORD      PUT-1
   704 33F8 F9 32		       .WORD      STATUS-1
   705 33FA 5F 33		       .WORD      SPEC-1
   706
   707 				       ; BANNERS
   708 				       
   709 33FC 23 46 55 4A 49 4E + BREADY .BYTE      '#FUJINET READY',$9B
   710 340B 23 46 55 4A 49 4E + BERROR .BYTE      '#FUJINET ERROR',$9B
   711
   712 				       ; VARIABLES
   713
   714 341A 00 00		DSAV   .WORD      $0000
   715 = 341C			TRIP   .DS      1       ; INTR FLAG
   716 = 341D			AX1SV  .DS      MAXDEV  ; AUX1 SAVE
   717 = 3421			AX2SV  .DS      MAXDEV  ; AUX2 SAVE
   718 = 3425			STSV   .DS      4*MAXDEV ; STATUS SAVE
   719 = 3435			RLEN   .DS      MAXDEV  ; RCV LEN
   720 = 3439			ROFF   .DS      MAXDEV  ; RCV OFFSET
   721 = 343D			TOFF   .DS      MAXDEV  ; TRX OFFSET
   722 = 3441			INQDS  .DS      1       ; DSTATS INQ
   723
   724 				       ; BUFFERS (PAGE ALIGNED)
   725
   726 3442				.ALIGN	$100
   727 					
   728 = 3500			RBUF	.DS	$80		; 128 bytes
   729 = 3580			TBUF	.DS	$80		; 128 bytes
   730 					
   731 = 3600			PGEND	= *
   732
   733 02E0-02E1> 00 31			RUN	START
   734 				       END
