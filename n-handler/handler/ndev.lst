mads 2.1.0 build 8 (23 Dec 19)
Source: ndev.s
     1 					;; N: Device Handler
     2 					;; Compile with MADS
     3
     4 					;; Author: Thomas Cherryhomes
     5 					;;   <thom.cherryhomes@gmail.com>
     6
     7 					;; CURRENT IOCB IN ZERO PAGE
     8 					
     9 = 0020			ZIOCB   =     $20      ; ZP IOCB
    10 = 0020			ZICHID  =     ZIOCB    ; ID
    11 = 0021			ZICDNO  =     ZIOCB+1  ; UNIT #
    12 = 0022			ZICCOM  =     ZIOCB+2  ; COMMAND
    13 = 0023			ZICSTA  =     ZIOCB+3  ; STATUS
    14 = 0024			ZICBAL  =     ZIOCB+4  ; BUF ADR LOW
    15 = 0025			ZICBAH  =     ZIOCB+5  ; BUF ADR HIGH
    16 = 0026			ZICPTL  =     ZIOCB+6  ; PUT ADDR L
    17 = 0027			ZICPTH  =     ZIOCB+7  ; PUT ADDR H
    18 = 0028			ZICBLL  =     ZIOCB+8  ; BUF LEN LOW
    19 = 0029			ZICBLH  =     ZIOCB+9  ; BUF LEN HIGH
    20 = 002A			ZICAX1  =     ZIOCB+10 ; AUX 1
    21 = 002B			ZICAX2  =     ZIOCB+11 ; AUX 2
    22 = 002C			ZICAX3  =     ZIOCB+12 ; AUX 3
    23 = 002D			ZICAX4  =     ZIOCB+13 ; AUX 4
    24 = 002E			ZICAX5  =     ZIOCB+14 ; AUX 5
    25 = 002F			ZICAX6  =     ZIOCB+15 ; AUX 6
    26
    27 = 000C			DOSINI  =     $0C      ; DOSINI
    28
    29 				       ; INTERRUPT VECTORS
    30 				       ; AND OTHER PAGE 2 VARS
    31
    32 = 0202			VPRCED  =     $0202   ; PROCEED VCTR
    33 = 02C6			COLOR2  =     $02C6   ; MODEF BKG C
    34 = 02E7			MEMLO   =     $02E7   ; MEM LO
    35 = 02EA			DVSTAT  =     $02EA   ; 4 BYTE STATS
    36
    37 				       ; PAGE 3
    38 				       ; DEVICE CONTROL BLOCK (DCB)
    39
    40 = 0300			DCB     =     $0300   ; BASE
    41 = 0300			DDEVIC  =     DCB     ; DEVICE #
    42 = 0301			DUNIT   =     DCB+1   ; UNIT #
    43 = 0302			DCOMND  =     DCB+2   ; COMMAND
    44 = 0303			DSTATS  =     DCB+3   ; STATUS/DIR
    45 = 0304			DBUFL   =     DCB+4   ; BUF ADR L
    46 = 0305			DBUFH   =     DCB+5   ; BUF ADR H
    47 = 0306			DTIMLO  =     DCB+6   ; TIMEOUT (S)
    48 = 0307			DRSVD   =     DCB+7   ; NOT USED
    49 = 0308			DBYTL   =     DCB+8   ; BUF LEN L
    50 = 0309			DBYTH   =     DCB+9   ; BUF LEN H
    51 = 030A			DAUXL   =     DCB+10  ; AUX BYTE L
    52 = 030B			DAUXH   =     DCB+11  ; AUX BYTE H
    53
    54 = 031A			HATABS  =     $031A   ; HANDLER TBL
    55
    56 				       ; IOCB'S * 8
    57
    58 = 0340			IOCB    =     $0340   ; IOCB BASE
    59 = 0340			ICHID   =     IOCB    ; ID
    60 = 0341			ICDNO   =     IOCB+1  ; UNIT #
    61 = 0342			ICCOM   =     IOCB+2  ; COMMAND
    62 = 0343			ICSTA   =     IOCB+3  ; STATUS
    63 = 0344			ICBAL   =     IOCB+4  ; BUF ADR LOW
    64 = 0345			ICBAH   =     IOCB+5  ; BUF ADR HIGH
    65 = 0346			ICPTL   =     IOCB+6  ; PUT ADDR L
    66 = 0347			ICPTH   =     IOCB+7  ; PUT ADDR H
    67 = 0348			ICBLL   =     IOCB+8  ; BUF LEN LOW
    68 = 0349			ICBLH   =     IOCB+9  ; BUF LEN HIGH
    69 = 034A			ICAX1   =     IOCB+10 ; AUX 1
    70 = 034B			ICAX2   =     IOCB+11 ; AUX 2
    71 = 034C			ICAX3   =     IOCB+12 ; AUX 3
    72 = 034D			ICAX4   =     IOCB+13 ; AUX 4
    73 = 034E			ICAX5   =     IOCB+14 ; AUX 5
    74 = 034F			ICAX6   =     IOCB+15 ; AUX 6
    75
    76 				       ; HARDWARE REGISTERS
    77
    78 = D302			PACTL   =     $D302   ; PIA CTRL A
    79
    80 				       ; OS ROM VECTORS
    81
    82 = E456			CIOV    =     $E456   ; CIO ENTRY
    83 = E459			SIOV    =     $E459   ; SIO ENTRY
    84
    85 				       ; CONSTANTS
    86
    87 = 0009			PUTREC  =     $09     ; CIO PUTREC
    88 = 0071			DEVIDN  =     $71     ; SIO DEVID
    89 = 0040			DSREAD  =     $40     ; FUJI->ATARI
    90 = 0080			DSWRIT  =     $80     ; ATARI->FUJI
    91 = 0004			MAXDEV  =     4       ; # OF N: DEVS
    92 = 0088			EOF     =     $88     ; ERROR 136
    93 = 009B			EOL     =     $9B     ; EOL CHAR
    94
    95 				;;; Macros ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    96
    97 					.MACRO DCBC
    98 					.LOCAL
    99 					LDY	#$0C
   100 				?DCBL	LDA	%%1,Y
   101 					STA	DCB,Y
   102 					DEY
   103 					BPL	?DCBL
   104 					.ENDL
   105 					.ENDM
   106 						
   107 				;;; Initialization ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   108 					
   109 				START:	
   110 FFFF> 3100-3425> A5 0C		LDA	DOSINI
   111 3102 8D 24 34			STA	DSAV
   112 3105 8D 25 31			STA	RESET+1
   113 3108 A5 0D			LDA	DOSINI+1
   114 310A 8D 25 34			STA	DSAV+1
   115 310D 8D 26 31			STA	RESET+2
   116 3110 A9 24			LDA	#<RESET
   117 3112 85 0C			STA	DOSINI
   118 3114 A9 31			LDA	#>RESET
   119 3116 85 0D			STA	DOSINI+1
   120
   121 					;;  Alter MEMLO
   122 					
   123 3118 A9 00			LDA	#<PGEND		
   124 311A 8D E7 02			STA	MEMLO
   125 311D A9 36			LDA	#>PGEND
   126 311F 8D E8 02			STA	MEMLO+1
   127
   128 3122 50 11			BVC	IHTBS
   129 					
   130 3124			RESET:
   131 3124 20 FF FF			JSR	$FFFF		; Jump to extant DOSINI
   132 3127 20 35 31			JSR	IHTBS		; Insert into HATABS
   133
   134 					;;  Alter MEMLO
   135 					
   136 312A A9 00			LDA	#<PGEND		
   137 312C 8D E7 02			STA	MEMLO
   138 312F A9 36			LDA	#>PGEND
   139 3131 8D E8 02			STA	MEMLO+1
   140
   141 					;; Back to DOS
   142 					
   143 3134 60				RTS
   144
   145 					;; Insert entry into HATABS
   146 					
   147 3135			IHTBS:
   148 3135 A0 00			LDY	#$00
   149 3137 B9 1A 03		IH1	LDA	HATABS,Y
   150 313A F0 0B			BEQ	HFND
   151 313C C9 4E			CMP	#'N'
   152 313E F0 07			BEQ	HFND
   153 3140 C8				INY
   154 3141 C8				INY
   155 3142 C8				INY
   156 3143 C0 21			CPY	#11*3
   157 3145 90 F0			BCC	IH1
   158
   159 					;; Found a slot
   160
   161 3147			HFND:
   162 3147 A9 4E			LDA	#'N'
   163 3149 99 1A 03			STA	HATABS,Y
   164 314C A9 FA			LDA	#<CIOHND
   165 314E 99 1B 03			STA	HATABS+1,Y
   166 3151 A9 33			LDA	#>CIOHND
   167 3153 99 1C 03			STA	HATABS+2,Y
   168
   169 					;; And we're done with HATABS
   170
   171 					;; Query FUJINET
   172
   173 3156 20 31 33			JSR	STPOLL
   174
   175 					;; Output Ready/Error
   176
   177 3159			OBANR:
   178 3159 A2 00			LDX	#$00		; IOCB #0
   179 315B A9 09			LDA	#PUTREC
   180 315D 9D 42 03			STA	ICCOM,X
   181 3160 A9 28			LDA	#$28		; 40 CHARS Max
   182 3162 9D 48 03			STA	ICBLL,X
   183 3165 A9 00			LDA	#$00
   184 3167 9D 49 03			STA	ICBLH,X
   185 316A AD 03 03			LDA	DSTATS		; Check DSTATS
   186 316D 10 0C			BPL	OBRDY		; < 128 = Ready
   187
   188 					;; Status returned error.
   189 					
   190 316F			OBERR:
   191 316F A9 15			LDA	#<BERROR
   192 3171 9D 44 03			STA	ICBAL,X
   193 3174 A9 34			LDA	#>BERROR
   194 3176 9D 45 03			STA	ICBAH,X
   195 3179 50 0A			BVC	OBCIO
   196
   197 					;; Status returned ready.
   198 					
   199 317B			OBRDY:	
   200 317B A9 06			LDA	#<BREADY
   201 317D 9D 44 03			STA	ICBAL,X
   202 3180 A9 34			LDA	#>BREADY
   203 3182 9D 45 03			STA	ICBAH,X
   204
   205 3185			OBCIO:
   206 3185 20 56 E4			JSR	CIOV
   207
   208 					;; Vector in proceed interrupt
   209
   210 3188			SPRCED:
   211 3188 A9 F3			LDA	#<PRCVEC
   212 318A 8D 02 02			STA	VPRCED
   213 318D A9 33			LDA	#>PRCVEC
   214 318F 8D 03 02			STA	VPRCED+1
   215
   216 					;; And we are done, back to DOS.
   217 					
   218 3192 60				RTS
   219
   220 				;;; End Initialization Code ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   221
   222 				;;; CIO OPEN ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   223
   224 3193			OPEN:
   225 					;; Prepare DCB
   226 					
   227 3193 20 EF 33			JSR	GDIDX		; Get Device ID in X (0-3)
   228 3196 A5 21			LDA	ZICDNO		; IOCB UNIT # (1-4)
   229 3198 8D E6 31			STA	OPNDCB+1	; Store in DUNIT
   230 319B A5 24			LDA	ZICBAL		; Get filename buffer
   231 319D 8D E9 31			STA	OPNDCB+4	; stuff in DBUF
   232 31A0 A5 25			LDA	ZICBAH		; ...
   233 31A2 8D EA 31			STA	OPNDCB+5	; ...
   234 31A5 A5 2A			LDA	ZICAX1		; Get desired AUX1/AUX2
   235 31A7 8D EF 31			STA	OPNDCB+10	; Save them, and store in DAUX1/DAUX2
   236 31AA 9D 27 34			STA	AX1SV,X		; ...
   237 31AD A5 2B			LDA	ZICAX2		; ...
   238 31AF 8D F0 31			STA	OPNDCB+11	; ...
   239 31B2 9D 2B 34			STA	AX2SV,X		; ...
   240
   241 					;;  Copy DCB template to DCB
   242 					
   243 31B5				DCBC	OPNDCB
Macro: DCBC [Source: ndev.s]
     2 31B5 A0 0C			LDY	#$0C
     3 31B7 B9 E5 31		?DCBL	LDA	OPNDCB,Y
     4 31BA 99 00 03			STA	DCB,Y
     5 31BD 88				DEY
     6 31BE 10 F7			BPL	?DCBL
Source: ndev.s
   244
   245 					;;  Send to #FujiNet
   246 					
   247 31C0 20 59 E4			JSR	SIOV
   248 				                                    
   249 					;; Return DSTATS, unless 144, then get extended error
   250 					
   251 31C3			OPCERR:
   252 31C3 AC 03 03			LDY	DSTATS		; GET SIO STATUS
   253 31C6 C0 90			CPY	#$90		; ERR 144?
   254 31C8 D0 06			BNE	OPDONE		; NOPE. RETURN DSTATS
   255 				       
   256 					;; 144 - get extended error
   257
   258 31CA 20 31 33			JSR	STPOLL  	; POLL FOR STATUS
   259 31CD AC ED 02			LDY	DVSTAT+3
   260
   261 				       ; RESET BUFFER LENGTH + OFFSET
   262 				       
   263 31D0			OPDONE:
   264 31D0 A9 01			LDA	#$01
   265 31D2 8D 26 34			STA	TRIP
   266 31D5 20 EF 33			JSR     GDIDX
   267 31D8 A9 00			LDA     #$00
   268 31DA 9D 3F 34			STA     RLEN,X
   269 31DD 9D 47 34			STA     TOFF,X
   270 31E0 9D 43 34			STA     ROFF,X
   271 31E3 98				TYA
   272 31E4 60				RTS             ; AY = ERROR
   273
   274 31E5			OPNDCB:
   275 31E5 71				.BYTE      DEVIDN  ; DDEVIC
   276 31E6 FF				.BYTE      $FF     ; DUNIT
   277 31E7 4F				.BYTE      'O'     ; DCOMND
   278 31E8 80				.BYTE      $80     ; DSTATS
   279 31E9 FF				.BYTE      $FF     ; DBUFL
   280 31EA FF				.BYTE      $FF     ; DBUFH
   281 31EB 0F				.BYTE      $0F     ; DTIMLO
   282 31EC 00				.BYTE      $00     ; DRESVD
   283 31ED 00				.BYTE      $00     ; DBYTL
   284 31EE 01				.BYTE      $01     ; DBYTH
   285 31EF FF				.BYTE      $FF     ; DAUX1
   286 31F0 FF				.BYTE      $FF     ; DAUX2
   287 					
   288 				;;; End CIO OPEN ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   289
   290 				;;; CIO CLOSE ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   291
   292 31F1			CLOSE:	
   293 31F1 20 E6 33			JSR     DIPRCD		; Disable Interrupts
   294 31F4 20 EF 33			JSR	GDIDX
   295 31F7 20 AF 32			JSR	PFLUSH		; Do a Put Flush if needed.
   296
   297 31FA A5 21			LDA     ZICDNO		; IOCB Unit #
   298 31FC 8D 13 32			STA     CLODCB+1	; to DCB...
   299 					
   300 31FF				DCBC	CLODCB		; Copy DCB into place
Macro: DCBC [Source: ndev.s]
     2 31FF A0 0C			LDY	#$0C
     3 3201 B9 12 32		?DCBL	LDA	CLODCB,Y
     4 3204 99 00 03			STA	DCB,Y
     5 3207 88				DEY
     6 3208 10 F7			BPL	?DCBL
Source: ndev.s
   301
   302 320A 20 59 E4			JSR	SIOV
   303
   304 320D AC 03 03			LDY	DSTATS		; Return SIO status
   305 3210 98				TYA
   306 3211 60				RTS			; Done.
   307
   308 3212 71			CLODCB .BYTE	DEVIDN		; DDEVIC
   309 3213 FF			       .BYTE	$FF		; DUNIT
   310 3214 43			       .BYTE	'C'		; DCOMND
   311 3215 00			       .BYTE	$00		; DSTATS
   312 3216 00			       .BYTE	$00		; DBUFL
   313 3217 00			       .BYTE	$00		; DBUFH
   314 3218 0F			       .BYTE	$0F		; DTIMLO
   315 3219 00			       .BYTE	$00		; DRESVD
   316 321A 00			       .BYTE	$00		; DBYTL
   317 321B 00			       .BYTE	$00		; DBYTH
   318 321C 00			       .BYTE	$00		; DAUX1
   319 321D 00			       .BYTE	$00		; DAUX2
   320 					
   321 				;;; End CIO CLOSE ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   322
   323 				;;; CIO GET ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   324
   325 321E			GET:
   326 321E 20 EF 33			JSR	GDIDX		; IOCB UNIT #-1 into X 
   327 3221 BD 3F 34			LDA	RLEN,X		; Get # of RX chars waiting
   328 3224 D0 37			BNE     GETDISC		; LEN > 0?
   329
   330 					;; If RX buffer is empty, get # of chars waiting...
   331 					
   332 3226 20 31 33			JSR	STPOLL		; Status Poll
   333 3229 20 EF 33			JSR	GDIDX		; IOCB UNIT -1 into X (because Poll trashes X)
   334 322C AD EA 02			LDA	DVSTAT		; # of bytes waiting (0-127)
   335 322F 9D 3F 34			STA	RLEN,X		; Store in RX Len
   336 3232 D0 05			BNE     GETDO		; We have something waiting...
   337
   338 					;; At this point, if RLEN is still zero, then return
   339 					;; with an EOF.
   340 					
   341 3234 A0 88			LDY     #EOF		; ERROR 136 - End of File
   342 3236 A9 88			LDA     #EOF
   343 3238 60				RTS
   344
   345 3239			GETDO:
   346 3239 A5 21			LDA	ZICDNO		; Get IOCB UNIT #
   347 323B 8D 83 32			STA	GETDCB+1	; Store into DUNIT
   348 323E AD EA 02			LDA	DVSTAT		; # of bytes waiting
   349 3241 8D 8A 32			STA	GETDCB+8	; Store into DBYT...
   350 3244 8D 8C 32			STA	GETDCB+10	; and DAUX1...
   351 				       
   352 3247				DCBC	GETDCB		; Prepare DCB
Macro: DCBC [Source: ndev.s]
     2 3247 A0 0C			LDY	#$0C
     3 3249 B9 82 32		?DCBL	LDA	GETDCB,Y
     4 324C 99 00 03			STA	DCB,Y
     5 324F 88				DEY
     6 3250 10 F7			BPL	?DCBL
Source: ndev.s
   353 					
   354 3252 20 59 E4			JSR	SIOV		; Call SIO to do the GET
   355
   356 					;; Clear the Receive buffer offset.
   357 					
   358 3255 20 EF 33			JSR	GDIDX		; IOCB UNIT #-1 into X
   359 3258 A9 00			LDA	#$00
   360 325A 9D 43 34			STA     ROFF,X
   361
   362 325D			GETDISC:
   363 325D AD EC 02			LDA     DVSTAT+2	; Did we disconnect?
   364 3260 D0 05			BNE     GETUPDP		; nope, update the buffer cursor.
   365
   366 					;; We disconnected, emit an EOF.
   367 					
   368 3262 A9 88			LDA	#EOF
   369 3264 A0 88			LDY	#EOF
   370 3266 60				RTS			; buh-bye.
   371
   372 3267			GETUPDP:
   373 3267 DE 3F 34			DEC     RLEN,X		; Decrement RX length.
   374 326A BC 43 34			LDY     ROFF,X		; Get RX offset cursor.
   375
   376 					;; Return Next char from appropriate RX buffer.
   377 					
   378 326D B9 00 35			LDA	RBUF,y
   379 					
   380 					;; Increment RX offset
   381 					
   382 3270 FE 43 34		GX:	INC	ROFF,X		; Increment RX offset.
   383 3273 A8				TAY			; stuff returned val into Y temporarily.
   384
   385 					;; If requested RX buffer is empty, reset TRIP.
   386
   387 3274 BD 3F 34			LDA	RLEN,X
   388 3277 D0 05			BNE	GETDONE
   389 3279 A9 00			LDA     #$00
   390 327B 8D 26 34			STA     TRIP
   391
   392 					;; Return byte back to CIO.
   393 					
   394 327E			GETDONE:
   395 327E 98				TYA			; Move returned val back.
   396 327F A0 01			LDY	#$01		; SUCCESS
   397
   398 3281 60				RTS			; DONE...
   399
   400 3282 71			GETDCB .BYTE     DEVIDN  ; DDEVIC
   401 3283 FF			       .BYTE     $FF     ; DUNIT
   402 3284 52			       .BYTE     'R'     ; DCOMND
   403 3285 40			       .BYTE     $40     ; DSTATS
   404 3286 00			       .BYTE     $00     ; DBUFL
   405 3287 35			       .BYTE     >RBUF   ; DBUFH
   406 3288 0F			       .BYTE     $0F     ; DTIMLO
   407 3289 00			       .BYTE     $00     ; DRESVD
   408 328A FF			       .BYTE     $FF     ; DBYTL
   409 328B 00			       .BYTE     $00     ; DBYTH
   410 328C FF			       .BYTE     $FF     ; DAUX1
   411 328D 00			       .BYTE     $00     ; DAUX2
   412 					
   413 				;;; End CIO GET ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   414
   415 				;;; CIO PUT ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   416
   417 328E			PUT:
   418 					;; Add to TX buffer.
   419
   420 328E 20 EF 33			JSR	GDIDX
   421 3291 BC 47 34			LDY	TOFF,X  ; GET TX cursor.
   422 3294 99 80 35			STA	TBUF,Y		; TX Buffer
   423 					
   424 3297 FE 47 34		POFF:	INC	TOFF,X		; Increment TX cursor
   425 329A A0 01			LDY	#$01		; SUCCESSFUL
   426
   427 					;; Do a PUT FLUSH if EOL or buffer full.
   428
   429 329C C9 9B			CMP     #EOL    ; EOL?
   430 329E F0 0B			BEQ     FLUSH  ; FLUSH BUFFER
   431 32A0 20 EF 33			JSR     GDIDX   ; GET OFFSET
   432 32A3 BD 47 34			LDA     TOFF,X
   433 32A6 C9 7F		        CMP     #$7F    ; LEN = $FF?
   434 32A8 F0 01		        BEQ     FLUSH  ; FLUSH BUFFER
   435 32AA 60			        RTS
   436
   437 				       ; FLUSH BUFFER, IF ASKED.
   438
   439 32AB 20 AF 32		FLUSH  JSR     PFLUSH  ; FLUSH BUFFER
   440 32AE 60			       RTS
   441
   442 32AF			PFLUSH:	
   443
   444 				       ; CHECK CONNECTION, AND EOF
   445 				       ; IF DISCONNECTED.
   446
   447 32AF 20 31 33		       JSR     STPOLL  ; GET STATUS
   448 32B2 AD EC 02		       LDA     DVSTAT+2
   449 32B5 D0 05		       BNE     PF1   
   450 32B7 A0 88		       LDY     #EOF
   451 32B9 A9 88		       LDA     #EOF
   452 32BB 60			       RTS
   453
   454 32BC 20 EF 33		PF1:	JSR     GDIDX   ; GET DEV X
   455 32BF BD 47 34		       LDA     TOFF,X
   456 32C2 D0 03		       BNE     PF2
   457 32C4 4C EB 32		       JMP     PDONE
   458
   459 				       ; FILL OUT DCB FOR PUT FLUSH
   460
   461 32C7 A5 21		PF2:	LDA     ZICDNO
   462 32C9 8D EF 32		       STA     PUTDCB+1
   463 					
   464 				       ; FINISH DCB AND DO SIOV
   465
   466 32CC BD 47 34		TBX:	LDA     TOFF,X
   467 32CF 8D F6 32			STA     PUTDCB+8
   468 32D2 8D F8 32			STA     PUTDCB+10
   469
   470 32D5				DCBC	PUTDCB
Macro: DCBC [Source: ndev.s]
     2 32D5 A0 0C			LDY	#$0C
     3 32D7 B9 EE 32		?DCBL	LDA	PUTDCB,Y
     4 32DA 99 00 03			STA	DCB,Y
     5 32DD 88				DEY
     6 32DE 10 F7			BPL	?DCBL
Source: ndev.s
   471 32E0 20 59 E4			JSR     SIOV
   472 				       
   473 				       ; CLEAR THE OFFSET CURSOR
   474 				       ; AND LENGTH
   475
   476 32E3 20 EF 33		       JSR     GDIDX
   477 32E6 A9 00		       LDA     #$00
   478 32E8 9D 47 34		       STA     TOFF,X
   479
   480 32EB A0 01		PDONE:	LDY     #$01
   481 32ED 60			       RTS
   482
   483 32EE 71			PUTDCB .BYTE      DEVIDN  ; DDEVIC
   484 32EF FF			       .BYTE      $FF     ; DUNIT
   485 32F0 57			       .BYTE      'W'     ; DCOMND
   486 32F1 80			       .BYTE      $80     ; DSTATS
   487 32F2 80			       .BYTE      $80     ; DBUFL
   488 32F3 35			       .BYTE      >TBUF   ; DBUFH
   489 32F4 0F			       .BYTE      $0F     ; DTIMLO
   490 32F5 00			       .BYTE      $00     ; DRESVD
   491 32F6 FF			       .BYTE      $FF     ; DBYTL
   492 32F7 00			       .BYTE      $00     ; DBYTH
   493 32F8 FF			       .BYTE      $FF     ; DAUX1
   494 32F9 00			       .BYTE      $00     ; DAUX2
   495 					
   496 				;;; End CIO PUT ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   497 					
   498 				;;; CIO STATUS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   499
   500 32FA			STATUS:
   501 32FA 20 DD 33			JSR     ENPRCD  ; ENABLE PRCD
   502 32FD 20 EF 33		       JSR     GDIDX   ; GET DEVICE#
   503 3300 BD 3F 34		       LDA     RLEN,X  ; GET RLEN
   504 3303 D0 05		       BNE     STSLEN  ; RLEN > 0?
   505 3305 AD 26 34		       LDA     TRIP
   506 3308 D0 16		       BNE     STTRI1  ; TRIP = 1?
   507
   508 				       ; NO TRIP, RETURN SAVED LEN
   509
   510 330A BD 3F 34		STSLEN LDA     RLEN,X  ; GET RLEN
   511 330D 8D EA 02		       STA     DVSTAT  ; RET IN DVSTAT
   512 3310 A9 00		       LDA     #$00
   513 3312 8D EB 02			STA     DVSTAT+1
   514 3315 A9 01			LDA	#$01
   515 3317 8D EC 02			STA	DVSTAT+2
   516 331A 8D ED 02			STA	DVSTAT+3
   517 					
   518 331D 4C 2B 33		       JMP     STDONE  ; DONE.
   519
   520 				       ; DO POLL AND UPDATE RCV LEN
   521
   522 3320 20 31 33		STTRI1 JSR     STPOLL  ; POLL FOR ST
   523 3323 9D 3F 34			STA	RLEN,X
   524 						
   525 				       ; UPDATE TRIP FLAG
   526
   527 3326 D0 03		STTRIU BNE     STDONE
   528 3328 8D 26 34		       STA     TRIP    ; RLEN = 0
   529
   530 				       ; RETURN CONNECTED? FLAG.
   531
   532 332B AD EC 02		STDONE LDA     DVSTAT+2
   533 332E A0 01			LDY	#$01
   534 3330 60			       RTS
   535
   536 				       ; ASK FUJINET FOR STATUS
   537
   538 3331			STPOLL:	
   539 3331 A5 21		       LDA     ZICDNO  ; IOCB #
   540 3333 8D 5F 33		       STA     STADCB+1
   541
   542 3336				DCBC	STADCB
Macro: DCBC [Source: ndev.s]
     2 3336 A0 0C			LDY	#$0C
     3 3338 B9 5E 33		?DCBL	LDA	STADCB,Y
     4 333B 99 00 03			STA	DCB,Y
     5 333E 88				DEY
     6 333F 10 F7			BPL	?DCBL
Source: ndev.s
   543
   544 3341 20 59 E4		       JSR     SIOV    ; DO IT...
   545
   546 					;; > 127 bytes? make it 127 bytes.
   547
   548 3344 AD EB 02			LDA	DVSTAT+1
   549 3347 D0 07			BNE	STADJ
   550 3349 AD EA 02			LDA	DVSTAT
   551 334C 30 02			BMI	STADJ
   552 334E 50 0A			BVC	STP2		; <= 127 bytes...
   553
   554 3350 A9 7F		STADJ	LDA	#$7F
   555 3352 8D EA 02			STA	DVSTAT
   556 3355 A9 00			LDA	#$00
   557 3357 8D EB 02			STA	DVSTAT+1
   558 					
   559 				       ; A = CONNECTION STATUS
   560
   561 335A AD EC 02		STP2   LDA     DVSTAT+2
   562 335D 60			       RTS
   563
   564 335E 71			STADCB .BYTE      DEVIDN  ; DDEVIC
   565 335F FF			       .BYTE      $FF     ; DUNIT
   566 3360 53			       .BYTE      'S'     ; DCOMND
   567 3361 40			       .BYTE      $40     ; DSTATS
   568 3362 EA			       .BYTE      $EA     ; DBUFL
   569 3363 02			       .BYTE      $02     ; DBUFH
   570 3364 0F			       .BYTE      $0F     ; DTIMLO
   571 3365 00			       .BYTE      $00     ; DRESVD
   572 3366 04			       .BYTE      $04     ; DBYTL
   573 3367 00			       .BYTE      $00     ; DBYTH
   574 3368 00			       .BYTE      $00     ; DAUX1
   575 3369 00			       .BYTE      $00     ; DAUX2
   576 					
   577 				;;; End CIO STATUS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   578
   579 				;;; CIO SPECIAL ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   580
   581 336A			SPEC:
   582 				       ; HANDLE LOCAL COMMANDS.
   583
   584 336A A5 22		       LDA     ZICCOM
   585 336C C9 0F		       CMP     #$0F    ; 15 = FLUSH
   586 336E D0 06		       BNE     S1      ; NO.
   587 3370 20 AF 32		       JSR     PFLUSH  ; DO FLUSH
   588 3373 A0 01		       LDY     #$01    ; SUCCESS
   589 3375 60			       RTS
   590
   591 				       ; HANDLE SIO COMMANDS.
   592 				       ; GET DSTATS FOR COMMAND
   593
   594 3376 A5 21		S1:	LDA	ZICDNO
   595 3378 8D D2 33			STA	SPEDCB+1
   596 337B A5 22			LDA	ZICCOM
   597 337D 8D DB 33			STA	SPEDCB+10
   598 					
   599 3380				DCBC	SPEDCB
Macro: DCBC [Source: ndev.s]
     2 3380 A0 0C			LDY	#$0C
     3 3382 B9 D1 33		?DCBL	LDA	SPEDCB,Y
     4 3385 99 00 03			STA	DCB,Y
     5 3388 88				DEY
     6 3389 10 F7			BPL	?DCBL
Source: ndev.s
   600 338B 20 59 E4		       JSR     SIOV    ; DO IT...
   601
   602 338E AD 03 03		       LDA     DSTATS
   603 3391 10 02		       BPL     :DSOK
   604 3393			DSERR:
   605 3393 A8				TAY             ; RET THE ERR
   606 3394 60			       RTS
   607
   608 				       ; WE GOT A DSTATS INQUIRY
   609 				       ; IF $FF, THE COMMAND IS
   610 				       ; INVALID
   611
   612 3395			DSOK:
   613 3395 AD 4B 34			LDA     INQDS
   614 3398 C9 FF		       CMP     #$FF    ; INVALID?
   615 339A D0 04		       BNE     DSGO   ; DO THE CMD
   616 339C A0 92		       LDY     #$92    ; UNIMP CMD
   617 339E 98			       TYA
   618 339F 60			       RTS
   619
   620 					;; Do the special, since we want to pass in all the IOCB
   621 					;; Parameters to the DCB, This is being done long-hand.
   622 					
   623 33A0 A5 22		DSGO:	LDA	ZICCOM
   624 33A2 8D 02 03			STA	DCOMND
   625 33A5 AD 4B 34			LDA	INQDS
   626 33A8 8D 03 03			STA	DSTATS
   627 33AB A5 24			LDA	ZICBAL
   628 33AD 8D 04 03			STA	DBUFL
   629 33B0 A5 25			LDA	ZICBAH
   630 33B2 8D 05 03			STA	DBUFH
   631 33B5 A9 00			LDA	#$00		; 256 bytes
   632 33B7 8D 08 03			STA	DBYTL
   633 33BA A9 01			LDA	#$01
   634 33BC 8D 09 03			STA	DBYTH
   635 33BF A5 2A			LDA	ZICAX1
   636 33C1 8D 0A 03			STA	DAUXL
   637 33C4 A5 2B			LDA	ZICAX2
   638 33C6 8D 0B 03			STA	DAUXH
   639
   640 33C9 20 59 E4			JSR	SIOV
   641
   642 					;; Return DSTATS in Y and A
   643
   644 33CC AD 03 03			LDA	DSTATS
   645 33CF A8				TAY
   646
   647 33D0 60				RTS
   648
   649 33D1 71			SPEDCB .BYTE      DEVIDN  ; DDEVIC
   650 33D2 FF			       .BYTE      $FF     ; DUNIT
   651 33D3 FF			       .BYTE      $FF     ; DCOMND ; inq
   652 33D4 40			       .BYTE      $40     ; DSTATS
   653 33D5 4B			       .BYTE      <INQDS  ; DBUFL
   654 33D6 34			       .BYTE      >INQDS  ; DBUFH
   655 33D7 0F			       .BYTE      $0F     ; DTIMLO
   656 33D8 00			       .BYTE      $00     ; DRESVD
   657 33D9 01			       .BYTE      $01     ; DBYTL
   658 33DA 00			       .BYTE      $00     ; DBYTH
   659 33DB FF			       .BYTE      $FF     ; DAUX1
   660 33DC FF			       .BYTE      $FF     ; DAUX2	
   661 					
   662 				;;; End CIO SPECIAL ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   663
   664 				;;; Utility Functions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   665
   666 				       ; ENABLE PROCEED INTERRUPT
   667
   668 33DD			ENPRCD:
   669 33DD AD 02 D3			LDA     PACTL
   670 33E0 09 01		       ORA     #$01    ; ENABLE BIT 0
   671 33E2 8D 02 D3		       STA     PACTL
   672 33E5 60			       RTS
   673
   674 				       ; DISABLE PROCEED INTERRUPT
   675
   676 33E6			DIPRCD:
   677 33E6 AD 02 D3			LDA     PACTL
   678 33E9 29 FE		       AND     #$FE    ; DISABLE BIT0
   679 33EB 8D 02 D3		       STA     PACTL
   680 33EE 60			       RTS
   681
   682 				       ; GET ZIOCB DEVNO - 1 INTO X
   683 				       
   684 33EF			GDIDX:	
   685 33EF A6 21		       LDX     ZICDNO  ; IOCB UNIT #
   686 33F1 CA			       DEX             ; - 1
   687 33F2 60			       RTS
   688 					
   689 				;;; End Utility Functions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   690
   691 				;;; Proceed Vector ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   692
   693 33F3			PRCVEC 
   694 33F3 A9 01		       LDA     #$01
   695 33F5 8D 26 34		       STA     TRIP
   696 33F8 68			       PLA
   697 33F9 40			       RTI
   698 					
   699 				;;; End Proceed Vector ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   700
   701 				;;; Variables
   702
   703 				       ; DEVHDL TABLE FOR N:
   704
   705 33FA 92 31		CIOHND .WORD      OPEN-1
   706 33FC F0 31		       .WORD      CLOSE-1
   707 33FE 1D 32		       .WORD      GET-1
   708 3400 8D 32		       .WORD      PUT-1
   709 3402 F9 32		       .WORD      STATUS-1
   710 3404 69 33		       .WORD      SPEC-1
   711
   712 				       ; BANNERS
   713 				       
   714 3406 23 46 55 4A 49 4E + BREADY .BYTE      '#FUJINET READY',$9B
   715 3415 23 46 55 4A 49 4E + BERROR .BYTE      '#FUJINET ERROR',$9B
   716
   717 				       ; VARIABLES
   718
   719 3424 00 00		DSAV   .WORD      $0000
   720 = 3426			TRIP   .DS      1       ; INTR FLAG
   721 = 3427			AX1SV  .DS      MAXDEV  ; AUX1 SAVE
   722 = 342B			AX2SV  .DS      MAXDEV  ; AUX2 SAVE
   723 = 342F			STSV   .DS      4*MAXDEV ; STATUS SAVE
   724 = 343F			RLEN   .DS      MAXDEV  ; RCV LEN
   725 = 3443			ROFF   .DS      MAXDEV  ; RCV OFFSET
   726 = 3447			TOFF   .DS      MAXDEV  ; TRX OFFSET
   727 = 344B			INQDS  .DS      1       ; DSTATS INQ
   728
   729 				       ; BUFFERS (PAGE ALIGNED)
   730
   731 344C				.ALIGN	$100
   732 					
   733 = 3500			RBUF	.DS	$80		; 128 bytes
   734 = 3580			TBUF	.DS	$80		; 128 bytes
   735 					
   736 = 3600			PGEND	= *
   737
   738 02E0-02E1> 00 31			RUN	START
   739 				       END
